[{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 function myInstanceOf(L, R) { const baseType = [\u0026#39;string\u0026#39;, \u0026#39;number\u0026#39;, \u0026#39;boolean\u0026#39;, \u0026#39;undefined\u0026#39;, \u0026#39;symbol\u0026#39;] if (baseType.includes(typeof(L))) return false if (!R.prototype) return false let proto = Object.getPrototypeOf(L) let prototype = R.prototype while (true) { if (proto === null) return false if (proto === prototype) return true proto = Object.getPrototypeOf(proto) } } ","date":"2022-07-08T00:00:00Z","permalink":"https://nomanplay.github.io/p/%E6%89%8B%E5%86%99instanceof/","title":"手写InstanceOf"},{"content":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class EventEmitter { constructor() { this.events = {} } //订阅 on(eventName, callback) { //新事件触发newListener if (!this.events[eventName]) { if (this.eventName !== \u0026#39;newListener\u0026#39;) { this.emit(\u0026#39;newListener\u0026#39;, eventName) } } // 由于一个事件可能注册多个回调函数，所以使用数组来存储事件队列 const callbacks = this.events[eventName] || [] callbacks.push(callback) this.events[eventName] = callbacks } //单次订阅 once(eventName, callback) { // 由于需要在回调函数执行后，取消订阅当前事件，所以需要对传入的回调函数做一层包装,然后绑定包装后的函数 const one = (...args) =\u0026gt; { callback(...args) this.off(eventName, one) } one.initialCallback = callback this.on(eventName, one) } //发布 emit(eventName, ...args) { const callbacks = this.events[eventName] || [] callbacks.forEach((cb) =\u0026gt; cb(...args)) } //取消订阅 off(eventName, callback) { //防止newListener被关闭 if (eventName === \u0026#39;newListener\u0026#39;) return //关闭对应callback const callbacks = this.events[eventName] || [] const newCallbacks = callbacks.filter( (fn) =\u0026gt; fn != callback \u0026amp;\u0026amp; fn.initialCallback != callback /* 用于once的取消订阅 */ ) this.events[eventName] = newCallbacks } } const events = new EventEmitter() //newLister用于监听新事件 events.on(\u0026#39;newListener\u0026#39;, function (eventName) { console.log(`eventName`, eventName) }) events.on(\u0026#39;hello\u0026#39;, function () { console.log(\u0026#39;hello\u0026#39;) }) console.log(\u0026#39;------\u0026#39;) let cb = function () { console.log(\u0026#39;cb\u0026#39;) } events.on(\u0026#39;hello\u0026#39;, cb) function once() { console.log(\u0026#39;once\u0026#39;) } events.once(\u0026#39;hello\u0026#39;, once) events.emit(\u0026#39;hello\u0026#39;) console.log(\u0026#39;------\u0026#39;) events.off(\u0026#39;hello\u0026#39;, cb) events.off(\u0026#39;hello\u0026#39;, once) events.emit(\u0026#39;hello\u0026#39;) ","date":"2022-07-04T00:00:00Z","permalink":"https://nomanplay.github.io/p/%E6%89%8B%E5%86%99%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/","title":"手写发布订阅模式"},{"content":"前端脚手架 目的 通过脚手架实现用一行命令导入不同模板：\nPC 端 React 移动端 Taro 实现的功能：\n一条简单的命令初始化项目 提供友好的交互体验 可选择安装不同模板 自动安装项目依赖 脚手架开发依赖 chalk:修改控制台输出内容样式\ncommander:命令行工具\ndownload-git-repo:用来下载远程模板\ninquirer:交互式命令行工具\nora:显示 loading 动画\nlog-symbols:显示出 √ 或 × 等的图标\nhandlebars.js:模板引擎\n","date":"2022-05-16T00:00:00Z","permalink":"https://nomanplay.github.io/p/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6/","title":"前端脚手架"},{"content":"R-Tree 认识 R-Tree B-Tree1的搜索本质是一维区间的划分过程，每次搜索节点就是一个子区间。\nR-Tree 是把 B-Tree 的思想拓展到多维空间，采用了 B-Tree 分割空间的思想，是一棵用来存储高维数据的平衡树2。\ngraph TB level3(level3)--\u003elevel2_1(level2_1) level3(level3)--\u003elevel2_2(level2_2) level2_1(level2_1)--\u003elevel1_1(level1_1) level2_1(level2_1)--\u003elevel1_2(level1_2) level2_2(level2_2)--\u003elevel1_3(level1_3) level2_2(level2_2)--\u003elevel1_4(level1_3) 对于 R-Tree 来说，叶子结点所在层级称为 level 1 ,根结点所在层级称为 level h ,R-tree 满足以下性质：\n所有非根节点包含 m-M 个记录索引（条目）。根结点的记录数可以小于 m。通常 m= $\\frac{M}{2}$ 每一个非叶子结点的分支数和该节点内的条目相同，一个条目对应一个分支，所有叶子节点都位于同一层，因此 R-Tree 为平衡树 叶子结点的每一个条目表示一个点 非叶子结点的每一个条目存放的数据结构为(I,child-pointer)。child-pointer是指向该条目对应孩子节点的指针，I表示一个 n 维空间的最小矩形边界(minimum bounding rectangle 即 MBR)，I覆盖了该条目对应子树中所有的矩形或点 两个黑点保存在一个页子节点的两个条目中，恰好框住这两个条目的矩形表示为 $I=(I_0,I_1)$。其中$I_0=(a,b)$，$I_1=(c,d)$，也就是说最小边界矩形是用各个维度的边表示，那么在三维空间中就是立方体，用 3 条边表示即可。\nhttps://en.wikipedia.org/wiki/B-tree\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n平衡树是计算机科学中的一类数据结构，为改进的二叉查找树。一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了。在平衡树这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-01-24T00:00:00Z","permalink":"https://nomanplay.github.io/p/r-tree/","title":"R-Tree"},{"content":"自动化脚本 crontab 语法 位置 含义 范围 * 分钟 0-59 * 小时 0-23 * 日期 1-31 * 月份 1-12 * 星期 0-7(0 和 7 都是周日) 编写 crontab 1 crontab -e //编辑crontab * * * * * 自动化执行 path/name.sh 需要执行的脚本 \u0026gt; path/name.txt 2\u0026gt;\u0026amp;1 \u0026amp; 将脚本执行后的结果 输入到name.txt文件上 1 2 3 crontab -l //查看crontab * * * * * path/name.sh \u0026gt; path/name.txt 2\u0026gt;\u0026amp;1 \u0026amp; 将会在规定时间时自动执行对应脚本\n","date":"2021-12-23T00:00:00Z","permalink":"https://nomanplay.github.io/p/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/","title":"自动化脚本"}]
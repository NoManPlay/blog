[{"content":"手写 Object.create 将传入的对象作为原型\n1 2 3 4 5 function create(obj) { function F() {} F.prototype = obj return new F() } 手写 instanceof instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置 实现步骤：\n首先获取类型的原型 然后获得对象的原型 然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null 1 2 3 4 5 6 7 8 9 10 11 12 function myInstanceof(left, right) { let proto = Object.getPrototypeOf(left), // 获取对象的原型 prototype = right.prototype // 获取构造函数的 prototype 对象 // 判断构造函数的 prototype 对象是否在对象的原型链上 while (true) { if (!proto) return false if (proto === prototype) return true proto = Object.getPrototypeOf(proto) } } 手写 new 在调用 new 的过程中会发生以上四件事情：\n首先创建了一个新的空对象 设置原型，将对象的原型设置为函数的 prototype 对象。 让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性） 判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 function myNew() { let newObj = null let constructor = Array.prototype.shift.call(arguments) let result = null // 判断参数是否是一个函数 if (typeof constructor !== \u0026#39;function\u0026#39;) { throw new Error(\u0026#39;请传入一个函数\u0026#39;) } //新建一个空对象，对象的原型为构造函数的prototype对象 newObj = Object.create(constructor.prototype) //将this指向新创建的对象，并调用构造函数 result = constructor.apply(newObj, arguments) //判断构造函数是否返回了一个对象 let flag = result \u0026amp;\u0026amp; (typeof result === \u0026#39;object\u0026#39; || typeof result === \u0026#39;function\u0026#39;) //判断返回结果 return flag ? result : newObj } //使用方法 function Car(make, model, year) { this.make = make this.model = model this.year = year } const car1 = myNew(Car, \u0026#39;Ford\u0026#39;, \u0026#39;Focus\u0026#39;, \u0026#39;2015\u0026#39;) console.log(car1.make) 手写 Promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 const PENDING = \u0026#39;PENDING\u0026#39; const FULFILLED = \u0026#39;FULFILLED\u0026#39; const REJECTED = \u0026#39;REJECTED\u0026#39; class MyPromise { constructor(executor) { try { executor(this.resolve, this.reject) } catch (error) { this.reject(error) } } status = PENDING value = null reason = null onFulfilledCallbacks = [] onRejectedCallbacks = [] resolve = (value) =\u0026gt; { if (this.status === PENDING) { this.status = FULFILLED this.value = value this.onFulfilledCallbacks.forEach((callback) =\u0026gt; callback(value)) } } reject = (reason) =\u0026gt; { if (this.status === PENDING) { this.status = REJECTED this.reason = reason this.onRejectedCallbacks.forEach((callback) =\u0026gt; callback(reason)) } } then(onFulfilled, onRejected) { onFulfilled = typeof onFulfilled === \u0026#39;function\u0026#39; ? onFulfilled : (value) =\u0026gt; value onRejected = typeof onRejected === \u0026#39;function\u0026#39; ? onRejected : (reason) =\u0026gt; { throw reason } const promise2 = new MyPromise((resolve, reject) =\u0026gt; { const fulfilledMicrotask = () =\u0026gt; { queueMicrotask(() =\u0026gt; { try { const x = onFulfilled(this.value) resolvePromise(promise2, x, resolve, reject) } catch (error) { reject(error) } }) } const rejectedMicrotask = () =\u0026gt; { queueMicrotask(() =\u0026gt; { try { const x = onRejected(this.reason) resolvePromise(promise2, x, resolve, reject) } catch (error) { reject(error) } }) } switch (this.status) { case PENDING: this.onFulfilledCallbacks.push(fulfilledMicrotask) this.onRejectedCallbacks.push(rejectedMicrotask) break case FULFILLED: fulfilledMicrotask() break case REJECTED: rejectedMicrotask() break default: break } }) return promise2 } catch(onRejected) { return this.then(null, onRejected) } finally(callback) { return this.then( (value) =\u0026gt; MyPromise.resolve(callback()).then(() =\u0026gt; value), (reason) =\u0026gt; MyPromise.resolve(callback()).then(() =\u0026gt; { throw reason }) ) } static resolve(parameter) { if (parameter instanceof MyPromise) { return parameter } return new MyPromise((resolve) =\u0026gt; { resolve(parameter) }) } static reject(reason) { return new MyPromise((resolve, reject) =\u0026gt; { reject(reason) }) } static all(promises) { const result = [] let count = 0 return new MyPromise((resolve, reject) =\u0026gt; { const addData = (index, value) =\u0026gt; { result[index] = value count++ if (count === promises.length) resolve(result) } promises.forEach((promise, index) =\u0026gt; { if (promise instanceof MyPromise) { promise.then( (value) =\u0026gt; { addData(index, value) }, (reason) =\u0026gt; { reject(reason) } ) } else { addData(index, promise) } }) }) } static race(promises) { return new MyPromise((resolve, reject) =\u0026gt; { promises.forEach((promise, index) =\u0026gt; { if (promise instanceof MyPromise) { promise.then( (res) =\u0026gt; resolve(res), (err) =\u0026gt; reject(err) ) } else { resolve(promise) } }) }) } static allSettled(promises) { return new MyPromise((resolve, reject) =\u0026gt; { const res = [] let count = 0 const addData = (status, value, index) =\u0026gt; { res[index] = {status, value} count++ if (count === promises.length) { resolve(res) } } promises.forEach((promise, index) =\u0026gt; { if (promise instanceof MyPromise) { promise.then( (res) =\u0026gt; addData(FULFILLED, res, index), (err) =\u0026gt; addData(REJECTED, err, index) ) } else { addData(FULFILLED, promise, index) } }) }) } static any(promises) { return new MyPromise((resolve, reject) =\u0026gt; { let count = 0 promises.forEach((promise) =\u0026gt; { promise.then( (res) =\u0026gt; resolve(res), (err) =\u0026gt; { count++ if (count === promises.length) { reject(new Error(\u0026#39;All promises were rejected\u0026#39;)) } } ) }) }) } } function resolvePromise(promise2, x, resolve, reject) { if (promise2 === x) return reject(new TypeError(\u0026#39;Chaining cycle detected for promise #\u0026lt;Promise\u0026gt;\u0026#39;)) if (x instanceof MyPromise) { x.then(resolve, reject) } else { resolve(x) } } 手写防抖 debounce 函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 function debounce(fn, wait) { let timer = null return function () { let context = this let args = arguments if (timer) { clearTimeout(timer) timer = null } timer = setTimeout(() =\u0026gt; { fn.apply(context, args) }, wait) } } 手写节流 throttle 1 2 3 4 5 6 7 8 9 10 11 12 13 14 function throttle(fn, delay) { let curTime = Date.now() return function () { let context = this let args = arguments let nowTime = Date.now() if (nowTime - curTime \u0026gt;= delay) { curTime = Date.now() return fn.apply(context, args) } } } 手写类型判断 1 2 3 4 5 function getType(value) { if (value === null) return value + \u0026#39;\u0026#39; if (typeof value === \u0026#39;object\u0026#39;) return Object.prototype.toString.call(value).slice(8, -1).toLowerCase() else return typeof value } 手写 call 1 2 3 4 5 6 7 8 9 10 11 12 13 Function.prototype.myCall = function (context) { if (typeof this !== \u0026#39;function\u0026#39;) { throw new TypeError(\u0026#39;Error\u0026#39;) } let args = [...arguments].slice(1) let result = null context = context || window context.fn = this result = context.fn(...args) delete context.fn return result } 手写 apply 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 Function.prototype.myApply = function (context) { if (typeof this !== \u0026#39;function\u0026#39;) { throw new TypeError(\u0026#39;Error\u0026#39;) } let result = null context = context || window context.fn = this if (arguments[1]) { result = context.fn(...arguments[1]) } else { result = context.fn() } delete context.fn return result } 手写 bind 1 2 3 4 5 6 7 8 9 10 11 Function.prototype.myBind = function (context) { if (typeof this !== \u0026#39;function\u0026#39;) { throw new TypeError(\u0026#39;Error\u0026#39;) } let args = [...arguments].slice(1) let fn = this return function Fn() { return fn.apply(this instanceof Fn ? this : context, args.concat(...arguments)) } } 柯里化实现 1 2 3 function curry(fn, ...args) { return fn.length \u0026lt;= args.length ? fn(...args) : curry.bind(null, fn, ...args) } 手写发布订阅模式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 class EventEmitter { constructor() { this.events = {} } //订阅 on(eventName, callback) { //新事件触发newListener if (!this.events[eventName]) { if (this.eventName !== \u0026#39;newListener\u0026#39;) { this.emit(\u0026#39;newListener\u0026#39;, eventName) } } // 由于一个事件可能注册多个回调函数，所以使用数组来存储事件队列 const callbacks = this.events[eventName] || [] callbacks.push(callback) this.events[eventName] = callbacks } //单次订阅 once(eventName, callback) { // 由于需要在回调函数执行后，取消订阅当前事件，所以需要对传入的回调函数做一层包装,然后绑定包装后的函数 const one = (...args) =\u0026gt; { callback(...args) this.off(eventName, one) } one.initialCallback = callback this.on(eventName, one) } //发布 emit(eventName, ...args) { const callbacks = this.events[eventName] || [] callbacks.forEach((cb) =\u0026gt; cb(...args)) } //取消订阅 off(eventName, callback) { //防止newListener被关闭 if (eventName === \u0026#39;newListener\u0026#39;) return //关闭对应callback const callbacks = this.events[eventName] || [] const newCallbacks = callbacks.filter( (fn) =\u0026gt; fn != callback \u0026amp;\u0026amp; fn.initialCallback != callback /* 用于once的取消订阅 */ ) this.events[eventName] = newCallbacks } } const events = new EventEmitter() //newLister用于监听新事件 events.on(\u0026#39;newListener\u0026#39;, function (eventName) { console.log(`eventName`, eventName) }) events.on(\u0026#39;hello\u0026#39;, function () { console.log(\u0026#39;hello\u0026#39;) }) console.log(\u0026#39;------\u0026#39;) let cb = function () { console.log(\u0026#39;cb\u0026#39;) } events.on(\u0026#39;hello\u0026#39;, cb) function once() { console.log(\u0026#39;once\u0026#39;) } events.once(\u0026#39;hello\u0026#39;, once) events.emit(\u0026#39;hello\u0026#39;) console.log(\u0026#39;------\u0026#39;) events.off(\u0026#39;hello\u0026#39;, cb) events.off(\u0026#39;hello\u0026#39;, once) events.emit(\u0026#39;hello\u0026#39;) ","date":"2022-07-04T00:00:00Z","permalink":"https://nomanplay.github.io/p/%E6%89%8B%E5%86%99%E6%96%B9%E6%B3%95/","title":"手写方法"},{"content":"前端脚手架 目的 通过脚手架实现用一行命令导入不同模板：\nPC 端 React 移动端 Taro 实现的功能：\n一条简单的命令初始化项目 提供友好的交互体验 可选择安装不同模板 自动安装项目依赖 脚手架开发依赖 chalk:修改控制台输出内容样式\ncommander:命令行工具\ndownload-git-repo:用来下载远程模板\ninquirer:交互式命令行工具\nora:显示 loading 动画\nlog-symbols:显示出 √ 或 × 等的图标\nhandlebars.js:模板引擎\n","date":"2022-05-16T00:00:00Z","permalink":"https://nomanplay.github.io/p/%E5%89%8D%E7%AB%AF%E8%84%9A%E6%89%8B%E6%9E%B6/","title":"前端脚手架"},{"content":"R-Tree 认识 R-Tree B-Tree1的搜索本质是一维区间的划分过程，每次搜索节点就是一个子区间。\nR-Tree 是把 B-Tree 的思想拓展到多维空间，采用了 B-Tree 分割空间的思想，是一棵用来存储高维数据的平衡树2。\ngraph TB level3(level3)--\u003elevel2_1(level2_1) level3(level3)--\u003elevel2_2(level2_2) level2_1(level2_1)--\u003elevel1_1(level1_1) level2_1(level2_1)--\u003elevel1_2(level1_2) level2_2(level2_2)--\u003elevel1_3(level1_3) level2_2(level2_2)--\u003elevel1_4(level1_3) 对于 R-Tree 来说，叶子结点所在层级称为 level 1 ,根结点所在层级称为 level h ,R-tree 满足以下性质：\n所有非根节点包含 m-M 个记录索引（条目）。根结点的记录数可以小于 m。通常 m= $\\frac{M}{2}$ 每一个非叶子结点的分支数和该节点内的条目相同，一个条目对应一个分支，所有叶子节点都位于同一层，因此 R-Tree 为平衡树 叶子结点的每一个条目表示一个点 非叶子结点的每一个条目存放的数据结构为(I,child-pointer)。child-pointer是指向该条目对应孩子节点的指针，I表示一个 n 维空间的最小矩形边界(minimum bounding rectangle 即 MBR)，I覆盖了该条目对应子树中所有的矩形或点 两个黑点保存在一个页子节点的两个条目中，恰好框住这两个条目的矩形表示为 $I=(I_0,I_1)$。其中$I_0=(a,b)$，$I_1=(c,d)$，也就是说最小边界矩形是用各个维度的边表示，那么在三维空间中就是立方体，用 3 条边表示即可。\nhttps://en.wikipedia.org/wiki/B-tree\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n平衡树是计算机科学中的一类数据结构，为改进的二叉查找树。一般的二叉查找树的查询复杂度取决于目标结点到树根的距离（即深度），因此当结点的深度普遍较大时，查询的均摊复杂度会上升。为了实现更高效的查询，产生了。在平衡树这里，平衡指所有叶子的深度趋于平衡，更广义的是指在树上所有可能查找的均摊复杂度偏低。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2022-01-24T00:00:00Z","permalink":"https://nomanplay.github.io/p/r-tree/","title":"R-Tree"},{"content":"自动化脚本 crontab 语法 位置 含义 范围 * 分钟 0-59 * 小时 0-23 * 日期 1-31 * 月份 1-12 * 星期 0-7(0 和 7 都是周日) 编写 crontab 1 crontab -e //编辑crontab * * * * * 自动化执行 path/name.sh 需要执行的脚本 \u0026gt; path/name.txt 2\u0026gt;\u0026amp;1 \u0026amp; 将脚本执行后的结果 输入到name.txt文件上 1 2 3 crontab -l //查看crontab * * * * * path/name.sh \u0026gt; path/name.txt 2\u0026gt;\u0026amp;1 \u0026amp; 将会在规定时间时自动执行对应脚本\n","date":"2021-12-23T00:00:00Z","permalink":"https://nomanplay.github.io/p/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC/","title":"自动化脚本"}]